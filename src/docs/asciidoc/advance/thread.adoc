[[redis-thread]]
== Redis 线程

=== Redis 是单线程还是多线程？

先来看看 Redis 有几个里程碑式的重要版本

image::{image-dir}/thread01.png[]

* 版本 3.x ,最早版本,也就是大家口口相传的 redis 是单线程
* 版本 4.x,严格意义来说也不是单线程,而是负责处理客户端请求的线程是单线程,但是开始加了点多线程的东西(异步删除)
* 最新版本的 6.0.x 后,告别了大家印象中的单线程,用一种全新的多线程来解决问题。

那我们常说的 Redis 是单线程是什么意思？

我们常说的 Redis 单线程其实是指事件处理上的。在了解事件处理上，先了解下 Redis 的工作机制。

Redis 服务器是一个事件驱动程序，服务器需要处理以下两类事件：

* 文件事件：Redis 服务器通过套接字与客户端（或者其他 Redis 服务器）进行连接，而文件事件就是服务器对套接字操作的抽象；服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作，比如连接 `accept`，`read`，`write`，`close`。
* 时间事件：Redis 服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象，比如过期键清理

Redis 将文件事件和时间事件进行抽象，时间轮训器会监听 I/O 事件表，一旦有文件事件就绪，Redis 就会优先处理文件事件，接着处理时间事件。

在所有事件处理上，Redis 都是以单线程形式处理，所以说 Redis 是单线程的。

.Redis 6.0 之前
====
image::{image-dir}/thread02.png[Redis 6.0]
====

但是 Redis 的其他功能，比如持久化 RDB，AOF，异步删除，集群数据同步等等，其实是有额外的线程执行的。

Redis 命令工作线程是单线程，但对于整个 Redis 来说，是多线程的。

=== Redis 架构演进

https://redis.io/docs/getting-started/faq/#how-can-redis-use-multiple-cpus-or-cores[How can Redis use multiple CPUs or cores?]

原文翻译：

Redis 是单线程的，如何利用多 CPU/内核？

CPU 并不是您使用 Redis 的瓶颈，因为通常 Redis 要么受内存限制，要么就是受网络限制。例如，在一个均衡的 Linux 系统上运行流水线的 Redis 实例每秒可以发送一百万个请求，因此如果您的应用程序主要使用 O(N) 或 O(log(N)) 命令，它几乎不会使用太多 CPU。

但是，为了最大限度地提高 CPU 使用率，您可以在一个机器上启用多个 Redis 实例，并将它们视为不同的服务器。在某个时候，单个实例可能不够用，所以如果你想使用多个 CPU，你可以提前考虑分片的方法。

您可以在 https://redis.io/topics/partitioning[分区页面] 中找到有关使用多个 Redis 实例的更多信息。

从版本 4.0 开始，Redis 已开始使用多个线程操作。目前，这仅限于在后台删除对象并阻止通过 Redis 模块实现的命令。对于后续版本，计划是使 Redis 越来越线程化。

==== Redis 3.0

* Redis 3.x 为什么采用单线程？
. 使用单线程模型是 Redis 的开发和维护更简单,因为单线程模型方便开发和调试；
. 即使使用单线程模型也并发的处理多客户端的请求,主要使用的是多路复用和非阻塞 IO
. 对于 Redis 系统来说,主要的性能瓶颈是内存或者网络带宽而并非 CPU

* Redis 3.x 单线程时代但性能依旧很快的主要原因
. 基于内存操作：Redis 的所有数据都存在内存中,因此所有的运算都是内存级别的,所以他的性能比较高
. 数据结构简单：Redis 的数据结构是专门设计的,而这些简单的数据结构的查找和操作的时间大部分复杂度都是 O(1),因此性能比较高
. <<redis-thread-io,多路复用和非阻塞 I/O>>：Redis 使用 I/O 多路复用功能来监听多个 socket 连接客户端,这样就可以使用一个线程连接来处理多个请求,减少线程切换带来的开销,同时也避免了 I/O 阻塞操作
. 避免上下文切换：因为是单线程模型,因此就避免了不必要的上下文切换和多线程竞争,这就省去了多线程切换带来的时间和性能上的消耗,而且单线程不会导致死锁问题的发生

==== Redis 4.0

上面说到了单线程的优势，既然单线程这么好,为什么逐渐又加入了多线程特性？

假设如果发生了一条耗时很长的命令，如：删除一个大 key，导致 Redis 服务器卡住了几秒，对负载高的缓存系统是一种灾难，因此，在 4.0 版本引入了 Lazy Free 机制，将慢操作异步化了。

什么是 Lazy Free 机制？就是将大键的删除操作异步化，采用非阻塞删除（对应命令 `UNLINK`，`flushdb async`，`flushall async`），大键的空间回收交由单独线程实现，主线程只做关系解除，可以快速返回，继续处理其他事件，避免服务器长时间阻塞。

==== Redis 6.0

Redis 在 4.0 版本引入了 Lazy Free，自此 Redis 有了一个 Lazy Free 线程专门用于大键的回收，但是大家都知道，Redis 的性能瓶颈并不在 CPU 上，而是在内存和网络上。所以 6.0 发布的多线程并未将事件处理（也既读写操作命令）改成多线程，而是在网络 I/O 上（即 <<redis-thread-io>>）。
如果把事件处理改成多线程，不但会导致锁竞争，而且会有频繁的上下文切换，即使用分段锁来减少竞争，对 Redis 内核也会有较大改动，性能也不一定有明显提升。 但是，6.0 版本的多线程并非彻底的多线程，I/O 线程只能同时执行读或者同时执行写操作，期间事件处理线程一直处于等待状态，并非流水线模型，有很多轮训等待开销。
在 Redis6.0 中，多线程机制默认是关闭的，需要在 `redis.conf` 中完成以下两个设置才能启用多线程。

* io-threads-do-reads yes ：设置 `io-thread-do-reads` 配置项为 `yes`，表示启用多线程。
* io-threads 6 ：设置线程个数。

⼀般来说，线程个数要小于 Redis 实例所在机器的 CPU 核数，例如，对于⼀个 4 核的机器来说，Redis 官⽅建议配置 2 个 或 3 个IO 线程。 线程数并不是越大越好，官方认为超过了 8 个基本就没什么意义了。

[[redis-thread-io]]
=== I/O 多路复用

我们现在已经知道了，影响 Redis 性能的因素主要集中在内存和网络 IO 上而并非是 CPU。而随着网络硬件的性能提升，Redis 的性能瓶颈更多的会出现在网络 IO 上，也就是说，单个线程处理网络请求的速度跟不上底层网络硬件的速度。

Redis 的多 I/O 线程只是用来处理网络请求的，对于读写操作命令 Redis 仍然使用单线程来处理。

==== Unix 网络编程中的五种 IO 模型

* Blocking IO - 阻塞 IO
* NoneBlocking IO - 非阻塞 IO
* IO multiplexing - IO 多路复用
* signal driven IO - 信号驱动 IO
* asynchronous IO - 异步 IO

Redis 中的 IO 线程主要依赖于 IO 多路复用，一种同步的 IO 模型，实现一个线程监视多个文件句柄，一旦某个文件句柄就绪就能够通知到对应的应用程序进行相应的读写操作，没有文件句柄就绪时就会阻塞应用程序，从而释放 CPU 资源。其中 IO 多路复用指：

* I/O: 网络 I/O，尤其在操作系统层面指数据在内核态和用户态之间的读写操作
* 多路：多个客户端连接（即 socket 或 channel）
* 复用：复用一个或多个线程
* I/O 多路复用,简单来说就是一个或一组线程处理多个 TCP 连接，使用单进程就能够实现同时处理多个客户端连接，无需创建或者维护过多的进程/线程

一句话，一个服务端进程可以同时处理多个套接字描述符。实现 IO 多路复用主要有三种函数: `select`,`poll`,`epoll`

Redis 处采用 Reactor 模式的网络模型，采用 `epoll` 函数，是最新的也是目前最好的多路复用技术。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求(尽量减少网络 IO 的时间消耗),且 Redis 在内存中操作数据的速度非常快(内存内的操作不会成为这里的性能瓶颈),主要以上两点造就了 Redis 具有很高的吞吐量

以下为 Redis 的主线程和 I/O 线程如何处理请求过程：

阶段一：服务端和客户端建立 socket 连接，并分配处理线程:: 首先，主线程负责接收建立连接请求，当有客户端请求和实例建立 Socket 连接时，主线程会创建和客户端的连接，并把 Socket 放入全局等待队列中，紧接着，主线程通过轮询方法吧 Socket 连接分配给 IO 线程

阶段二：IO 线程读取并解析请求:: 主线程一旦把 Socket 分配给 IO 线程后，就会进入阻塞状态，等待 IO 线程完成客户端请求读取和鸡西，因为有多个 IO 线程在并行处理，所以，这个过程会很快

阶段三：主线程继续执行请求操作:: 等到 IO 线程解析完请求，主线程还是会以单线程的方式执行这些命令操作

阶段四：IO 线程回写 Socket 和主线程清空全局队列:: 当主线程执行完请求操作后，会把需要返回的结果写入缓冲区，然后，主线程会阻塞等待 IO 线程，把这些结果回写到 Socket 中，并返回给客户端，和 IO 线程读写和解析请求一样，IO 线程回写 Socket 时，也是有多个线程在并发执行，所以回写 Socket 的速度也很快。
等到 IO 线程回写 Socket 完毕，主线程会清空全局队列，等待客户端的后续请求。

当客户端请求服务端时，实际上就是在服务端的 Socket 文件中写入客户端对应的文件描述符，如果有多个客户端同时请求服务器，为每次请求分配一个线程，类似每次来都 new 一个，如此会比较耗费服务端资源。因此，我们只使用一个线程来监听多个文件描述符，
这就是 IO 多路复用，采用 IO 多路复用技术可以让单个线程高效的处理多个连接请求，一个服务端进程可以同时处理多个套接字描述符。

在 Redis 6.0 中新增了多线程的功能来提高 I/O 的读写性能,他的主要实现思路是将主线程的 IO 读写任务拆分给一组独立的线程去执行,这样就可以使多个 socket 的读写可以并行化了,采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求(尽量减少网络 IO 的时间消耗),
将最耗时的 Socket 的读取、请求解析、写入单独外包出去,剩下的命令执行仍然由主线程串行执行并和内存的数据交互

image::{image-dir}/thread03.png[]

Redis 6.0 将网络数据读写、请求协议解析通过多个 IO 线程的来处理 ,对于真正的命令执行来说,仍然使用主线程操作

image::{image-dir}/thread04.png[]

==== 总结

* Redis 自身出道就是优秀,基于内存操作、数据结构简单、多路复用和非阻塞 I/O、避免了不必要的线程上下文切换等特性,在单线程的环境下依然很快
* 但对于大数据的 key 删除还是卡顿厉害,因此在 Redis 4.0 引入了多线程 unlink key/flushall async 等命令,主要用于 Redis 数据的异步删除
* Redis 6.0 将网络数据读写、请求协议解析通过多个 IO 线程的来处理,而命令的执行依旧是由主线程串行执行的,因此在多线程下操作 Redis 不会出现线程安全的问题
* Redis 无论是当初的单线程设计,还是如今与当初设计相背的多线程,目的只有一个: 让Redis 变得越来越快